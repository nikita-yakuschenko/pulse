# Подключение к Postgres на self-hosted Supabase с домашнего ПК

Порты 5432 и 6543 на VPS ведут в **pooler (Supavisor)**, а не в сам Postgres. Поэтому при подключении снаружи возникает «Tenant or user not found».

Чтобы подключаться с домашнего ПК **без выхода БД в интернет**, делаем так:

---

## Шаг 1. Один раз на VPS: проброс Postgres только на localhost

Нужно пробросить порт контейнера **db** (Postgres) на хост VPS **только на 127.0.0.1** — в интернет он не попадает.

### Если Supabase поднят через Docker Compose

1. На VPS найдите папку с Supabase (где лежит `docker-compose.yml`).
2. Найдите секцию сервиса **db** (контейнер с Postgres).
3. Добавьте в него блок `ports` (если его нет) или допишите строку:

```yaml
db:
  # ... остальные настройки (image, volumes, environment и т.д.) ...
  ports:
    - "127.0.0.1:5434:5432"
```

Порт **5434** на хосте — чтобы не пересекаться с pooler (он уже занимает 5432).  
**127.0.0.1** — слушаем только localhost, снаружи порт недоступен.

4. Перезапустите только сервис db (или весь stack):

```bash
docker compose up -d db
# или
docker compose up -d
```

### Если Supabase развёрнут через Dokploy

Compose берётся из Git-репо. Нужно добавить порт в секцию `db` и задеплоить заново.

#### Вариант А: Форк репо (рекомендуется, правки сохраняются)

1. **В Dokploy:** открой приложение Supabase → вкладка **General** → посмотри **Source** (какой репо и ветка) и **Compose Path** (например `./docker-compose.yml` или `docker-compose.dokploy.yml`).

2. **Форкни этот репо** на GitHub (кнопка Fork).

3. **В своём форке** открой файл compose (по пути из Compose Path). Найди секцию `db:` (Postgres). Добавь блок `ports`:
   ```yaml
   db:
     container_name: supabase-db
     # ... остальное ...
     ports:
       - "127.0.0.1:5434:5432"
   ```
   Важно: отступы как у других полей в `db`.

4. **Commit и push** в свой форк.

5. **В Dokploy:** General → поменяй Source на свой форк (URL своего репо, та же ветка) → **Deploy** (Redeploy).

6. После деплоя на VPS порт 5434 будет слушаться. Проверка по SSH:
   ```bash
   nc -zv 127.0.0.1 5434
   ```
   Должно быть `succeeded` вместо `Connection refused`.

#### Вариант Б: Редактирование через SSH (временно, до следующего Deploy)

1. **SSH на VPS:**
   ```bash
   ssh root@155.212.147.165
   ```

2. **Найди compose-файл Supabase:**
   ```bash
   find / -name "docker-compose*.yml" 2>/dev/null | xargs grep -l "supabase-db" 2>/dev/null
   ```
   Или:
   ```bash
   docker ps --format '{{.Names}}' | grep -E 'supabase|db'
   docker inspect supabase-db --format '{{index .Config.Labels "com.docker.compose.project.working_dir"}}'
   ```
   В выводе — путь к папке проекта. Compose лежит там.

3. **Отредактируй файл** (подставь свой путь):
   ```bash
   nano /путь/к/проекту/docker-compose.yml
   ```
   В секции `db:` добавь:
   ```yaml
   ports:
     - "127.0.0.1:5434:5432"
   ```

4. **Пересоздай контейнер db:**
   ```bash
   cd /путь/к/проекту
   docker compose up -d db
   ```

5. Проверка: `nc -zv 127.0.0.1 5434` — должно быть `succeeded`.

**Внимание:** при следующем Deploy из Dokploy файлы могут перезаписаться из Git — правки пропадут. Для постоянного решения используй Вариант А (форк).

---

## Шаг 2. На домашнем ПК: SSH-туннель

В отдельном терминале (оставьте его открытым на время работы):

```bash
ssh -L 5433:127.0.0.1:5434 ВАШ_ПОЛЬЗОВАТЕЛЬ@IP_VPS
```

Подставьте:
- `ВАШ_ПОЛЬЗОВАТЕЛЬ` — пользователь SSH на VPS;
- `IP_VPS` — IP или домен VPS (например `155.212.147.165`).

Так вы «пробрасываете» локальный порт 5433 на своём ПК в порт 5434 на VPS (а тот уже ведёт в Postgres).

---

## Шаг 3. В проекте Pulse

В `.env` должна быть строка (она уже настроена):

```env
DATABASE_URL="postgresql://postgres:ПАРОЛЬ@127.0.0.1:5433/postgres"
```

Пароль — ваш `POSTGRES_PASSWORD` из конфига Supabase на VPS.

Запустите приложение:

```bash
npm run dev
```

Регистрация и вход должны работать: приложение подключается к `127.0.0.1:5433` → туннель → VPS:5434 → Postgres. В интернет база не открыта.

---

## Почему `npm run db:push` выдаёт «Can't reach database server at 127.0.0.1:5433»?

- **Авторизация** в приложении идёт через Supabase по **HTTP** (NEXT_PUBLIC_SUPABASE_URL). К Postgres напрямую приложение при логине не подключается — поэтому авторизация работает без туннеля.
- **Prisma** (`db:push`, миграции, seed) подключается к БД по **DATABASE_URL** — это прямое подключение к PostgreSQL на `127.0.0.1:5433`.

Порт 5433 на вашем ПК — это локальный конец SSH-туннеля. Если туннель **не запущен**, на 5433 никто не слушает → Prisma не может подключиться.

**Что делать:** перед `npm run db:push` (или любыми командами Prisma к этой БД) откройте туннель (Шаг 2 выше) в отдельном терминале и не закрывайте его на время работы с БД.
